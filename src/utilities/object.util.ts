// Types
import {
  CompareFilterCallback,
  CompareOutputCallback,
} from "@typings/compare.types";

/**
 * Compare objects recursively (with deep merging)
 *
 * @param   baseObject       -
 * @param   comparisonObject -
 * @param   parents          - List of parent keys
 * @param   outputCallback   - Callback to generate actual comparison output
 * @param   filterCallback   - Callback to ignore items by key/values
 * @returns Comparison output (generated by callback)
 */
const compareObjects = (
  baseObject: any = {},
  comparisonObject: any = {},
  parents: string[] = [],
  outputCallback: CompareOutputCallback,
  filterCallback?: CompareFilterCallback,
) => {
  const output: any = {};
  const merged = { ...baseObject, ...comparisonObject };

  for (const key in merged) {
    const value1 = baseObject[key];
    const value2 = comparisonObject[key];

    // Optional filter for ignoring keys/values
    if (filterCallback && !filterCallback(key, value1, value2)) continue;

    let comparisonOutput;

    // Recursively compare nested objects
    if (isObject(value1) || isObject(value2)) {
      const comparison = compareObjects(
        value1 ?? undefined,
        value2 ?? undefined,
        [...parents, key],
        outputCallback,
        filterCallback,
      );

      comparisonOutput = outputCallback(
        value1,
        value2,
        key,
        parents,
        comparison,
      );
    }
    // Scalar values indicate the "lowest chain" of a nested object
    else {
      comparisonOutput = outputCallback(value1, value2, key, parents);
    }

    // Output callback can return 'undefined' to remove/ignore keys/values in output
    if (comparisonOutput !== undefined) {
      output[key] = comparisonOutput;
    }
  }

  return output;
};

/**
 * Determine whether a value is an object
 *
 * @param   value - Value to check
 * @returns Whether value is an object
 */
const isObject = (value: any): boolean =>
  Boolean(value) && typeof value === "object";

/**
 * Join parents (and key) together for display
 *
 * @param   parents - Parent keys
 * @param   key     - Current key
 * @returns Joined parent keys
 */
const joinParents = (parents: string[], key?: string): string => {
  const finalList = key ? [...parents, key] : parents;
  return finalList.join(" -> ");
};

export { compareObjects, isObject, joinParents };
