// Types
import {
  CompareFilterCallback,
  CompareOutputCallback,
} from "@typings/compare.types";

/**
 * Compare objects recursively (with deep merging)
 *
 * @param   baseObject       -
 * @param   comparisonObject -
 * @param   parents          - List of parent keys
 * @param   outputCallback   - Callback to generate actual comparison output
 * @param   filterCallback   - Callback to ignore items by key/values
 * @returns Comparison output (generated by callback)
 */
const compareObjects = (
  baseObject: any = {},
  comparisonObject: any = {},
  parents: string[] = [],
  outputCallback: CompareOutputCallback,
  filterCallback?: CompareFilterCallback,
) => {
  const output: any = {};
  const merged = { ...baseObject, ...comparisonObject };

  for (const key in merged) {
    const value1 = baseObject[key];
    const value2 = comparisonObject[key];

    // Optional filter for ignoring keys/values
    if (filterCallback && !filterCallback(key, value1, value2)) continue;

    let comparisonOutput;

    // Recursively compare nested objects
    if (isObject(value1) || isObject(value2)) {
      const comparison = compareObjects(
        value1 ?? undefined,
        value2 ?? undefined,
        [...parents, key],
        outputCallback,
        filterCallback,
      );

      comparisonOutput = outputCallback(
        value1,
        value2,
        key,
        parents,
        comparison,
      );
    }
    // Scalar values indicate the "lowest chain" of a nested object
    else {
      comparisonOutput = outputCallback(value1, value2, key, parents);
    }

    // Output callback can return 'undefined' to remove/ignore keys/values in output
    if (comparisonOutput !== undefined) {
      output[key] = comparisonOutput;
    }
  }

  return output;
};

/**
 * Determine whether a value is an object
 *
 * @param   value - Value to check
 * @returns Whether value is an object
 */
const isObject = (value: any): boolean =>
  Boolean(value) && typeof value === "object";

/**
 * Dynamically sets a deeply nested value in an object (returns new object)
 *
 * NOTE: By default it will create any missing nested keys!
 *
 * @param   obj       - Object which contains the value to set
 * @param   path      - Path to nested key being set
 * @param   value     - Target value to set
 * @param   recursive - Whether to create non-existing paths
 * @returns Updated nested object
 */
const setDeep = (
  obj: Record<string, any> = {},
  [first, ...rest]: string[],
  value: any,
  recursive = true,
): Record<string, any> => {
  // Optional prevent creating recursive keys if path is invalid/missing
  if (!recursive && typeof obj[first] === "undefined") return obj;
  // Arrays are currently not supported (will ignore)
  if (Array.isArray(obj[first])) return obj;

  return {
    ...obj,
    [first]: rest.length ? setDeep(obj[first], rest, value, recursive) : value,
  };
};

export { compareObjects, isObject, setDeep };
